---
title: 📚 数据结构与算法 - 单调栈与括号匹配综合笔记
date: 2026-02-04 10:00:00
tags:
  - 算法
  - 栈
  - 单调栈
  - 括号匹配
categories:
  - 算法学习
cover: /img/cover2.png
description: 深入理解栈的两大核心应用场景：单调栈与括号匹配，包含详细思路解析、代码实现与综合总结。
---

## 前言

{% note success flat %}
**栈（Stack）** 是数据结构中最经典的结构之一，它的核心本质不是"存储数据"，而是**推迟决策**。本文将通过 LeetCode 两道经典题目，深入理解栈在算法中的两大核心应用场景。
{% endnote %}

---

## 题目 1：每日温度（单调栈）

{% note primary flat %}
**LeetCode 739** | **栈的应用** | **时间复杂度 O(n)**
{% endnote %}

### 核心思路

对每个位置，找**右边第一个更大的元素**，返回距离。

{% note info flat %}
**单调栈的特点**：
- 栈中元素对应的值保持 **单调递减**
- 栈中保存的是：**还没找到答案的元素下标**
- 一旦当前元素破坏单调性（当前值更大），就可以为栈顶元素结算答案
{% endnote %}

### 为什么存下标而不是值？

- 需要计算距离：`i - idx`
- 需要修改答案数组中指定位置 `ans[idx] = i - idx`

### 标准模板（右边第一个更大）

1. 从左往右遍历，栈维持单调递减
2. 当前值 > 栈顶值时：循环出栈并结算答案
3. 当前下标入栈

### 细节/坑点

| 坑点 | 解决方案 |
|:---:|:---|
| 栈里存的是**下标** | 比较时要用 `temps[i] > temps[stk.top()]` |
| 出栈时用 `while` 循环 | 不是 `if`（可能连续弹出多个） |
| 初始化答案数组为 0 | 表示右边没有更大值 |

### 复杂度分析

| 复杂度 | 说明 |
|:---:|:---|
| **时间** | $O(n)$ - 每个元素最多入栈、出栈各一次 |
| **空间** | $O(n)$ - 栈和答案数组 |

### 代码实现

```cpp
vector<int> dailyTemperatures(vector<int>& temps) {
    int n = temps.size();
    vector<int> ans(n, 0);
    stack<int> stk; // 存下标

    for (int i = 0; i < n; i++) {
        // 当前温度更高，可以为之前的元素结算
        while (!stk.empty() && temps[i] > temps[stk.top()]) {
            int idx = stk.top();
            stk.pop();
            ans[idx] = i - idx;
        }
        stk.push(i);
    }
    return ans;
}
```

---

## 题目 2：有效的括号（栈匹配）

{% note primary flat %}
**LeetCode 20** | **栈匹配** | **时间复杂度 O(n)**
{% endnote %}

### 核心思路

成对结构 + 顺序嵌套 → 用 **栈（后进先出）** 维护。

{% note info flat %}
**匹配规则**：
- 左括号：入栈
- 右括号：与栈顶匹配，匹配成功则出栈，否则直接返回 false
- 最终栈必须为空
{% endnote %}

### 关键设计

用哈希表存**右括号 → 左括号**的映射，便于快速验证。

### 处理流程

| 步骤 | 操作 |
|:---:|:---|
| 1 | 遍历字符串 |
| 2 | 左括号 `(` `[` `{`：入栈 |
| 3 | 右括号：检查栈是否为空 + 栈顶是否匹配 |
| 4 | 遍历结束后，栈必须为空 |

### 细节/坑点

{% note warning flat %}
**特别注意**：
- 长度为奇数直接返回 `false`（可提前剪枝）
- 右括号来时栈可能已空，要先判断 `stk.empty()`
- 栈中保存的是"还没被匹配的左括号"
{% endnote %}

### 复杂度分析

| 复杂度 | 说明 |
|:---:|:---|
| **时间** | $O(n)$ - 只需遍历一次 |
| **空间** | $O(n)$ - 最坏情况全是左括号 |

### 代码实现

```cpp
bool isValid(string s) {
    if (s.size() % 2 == 1) return false;

    unordered_map<char,char> mp = {{')', '('}, {']', '['}, {'}', '{'}};
    stack<char> stk;

    for (char c : s) {
        if (c == '(' || c == '[' || c == '{') {
            stk.push(c);
        } else {
            if (stk.empty() || stk.top() != mp[c]) return false;
            stk.pop();
        }
    }
    return stk.empty();
}
```

---

## 今日主题：栈的综合总结

{% note success flat %}
### 两类题目的共通本质

**共同点**
- 都利用了 **栈的"后进先出"特性**
- 栈中保存的是："当前无法确定答案的元素"
- 遇到合适的触发条件时，立即结算栈顶
{% endnote %}

### 区别对比

| 类型 | 栈的作用 |
|:---:|:---:|
| **单调栈** | 维护顺序 + 推迟结算 |
| **括号匹配** | 维护结构 + 合法性检查 |

---

## 识别技巧

{% note primary flat %}
一看到这些关键词，优先想栈：
{% endnote %}

| 关键词 | 应用场景 |
|:---:|:---|
| **下一个 / 最近的** | 单调栈 |
| **右边第一个更大 / 更小** | 单调栈 |
| **匹配 / 嵌套 / 成对** | 括号匹配 |
| **消除 / 抵消** | 括号匹配 |
| **合法性判断** | 括号匹配 |

### 判断用哪种栈

- 需要**大小比较** → **单调栈**
- 需要**结构匹配** → **普通栈**

---

## 做题自检问题

{% note info flat %}
在解决栈相关题目时，依次问自己这四个问题：
{% endnote %}

1. **栈里存的是什么？**
2. **什么时候入栈？**
3. **什么时候出栈？**
4. **出栈时是否可以立刻确定答案？**

---

## 一句话总结

{% note warning flat %}
> **栈的本质不是存数据，而是推迟决策；**
>
> **谁最晚入场、却必须最先被处理，谁就该进栈。**
{% endnote %}

---

## 常见变形题目

### 单调栈类

| 题目 | 难度 | 说明 |
|:---:|:---:|:---|
| 下一个更大元素 I | 中等 | 基础单调栈 |
| 下一个更大元素 II | 中等 | 循环数组 |
| 股票价格跨度 | 中等 | 栈 + 历史记录 |
| 接雨水 | 困难 | 单调栈 + 双指针 |
| 子数组最小值贡献 | 困难 | 单调栈进阶 |

### 括号匹配类

| 题目 | 难度 | 说明 |
|:---:|:---:|:---|
| 最长有效括号 | 困难 | 栈 / 动态规划 |
| 括号生成 | 中等 | DFS + 剪枝 |
| 字符串解码 | 中等 | 栈处理嵌套 |
| 表达式求值 | 困难 | 栈综合应用 |

---

## 今日打卡

{% note success flat %}
### 核心要点回顾
{% endnote %}

| 知识点 | 核心要点 |
|:---:|:---|
| **单调栈** | 栈存下标，维护单调递减；当前值破坏单调性时循环出栈结算，复杂度 $O(n)$ |
| **括号匹配** | 左括号入栈，右括号与栈顶匹配；最终栈空才合法 |
| **核心思想** | 栈 = 推迟决策，"还没确定答案的元素"暂存其中，遇到触发条件立即结算 |

---

{% note primary flat %}
**相关阅读**
- [链表双指针技巧](/2026/01/29/linkedlist-two-pointers/)
- [链表反转与环形检测](/2026/01/29/reverse-and-cycle/)
{% endnote %}
